/* File automatically generated by ./asdl_cpp.py. */

#include <set>
#include <sstream>

#include "AST.h"

namespace AST {

typedef std::string identifier;
typedef void* pointer;

expr_t BinOp(expr_t left, operator_t op, expr_t right) {
    return new BinOp_(left, op, right);
}

expr_t IntLit(int n) {
    return new IntLit_(n);
}


class ToStringVisitor : public BaseVisitor {

    std::string to_string(std::string& value) {
        return value;
    }
    template <class T>
    typename std::enable_if<std::is_arithmetic<T>::value, std::string>::type
    to_string(T value) {
        return std::to_string(value);
    }
    template <class T>
    typename std::enable_if<std::is_enum<T>::value, std::string>::type
    to_string(T value) {
        return std::any_cast<std::string>(visit(value));
    }
    template <class T>
    std::string to_string(T* value) {
        std::ostringstream oss;
        oss << value;
        return oss.str();
    }
    template <class T>
    std::string to_string(std::vector<T>& values) {
        std::string result = "[";
        if (!values.empty()) {
            result += to_string(values[0]);
            for (size_t i = 1; i < values.size(); i++) {
                result += ", ";
                result += to_string(values[i]);
            }
        }
        result += "]";
        return result;
    }
    template <class T>
    std::string follow(T value) {
        return std::string();
    }
    std::set<void*> already_visited_;
    template <class T>
    std::string follow(T* value) {
        bool placed = already_visited_.insert(value).second;
        return (placed && value) ? std::any_cast<std::string>(visit(value))
                                 : std::string();
    }
    std::string follow(void* value) {
        return std::string();
    }
    template <class T>
    std::string follow(std::vector<T>& values) {
        std::string result;
        for (auto& value: values) {
            result += follow(value);
        }
        return result;
    }
    size_t depth = 0;
    std::string spaces() {
        std::string result = "";
        for (size_t i = 0; i < depth; i++) {
            result += ' ';
        }
        return result;
    }
        
public:
    std::any visitBinOp(BinOp_t node) override {
        std::string result = spaces() + to_string(node) + " BinOp(";
        result += "left=" + to_string(node->left) + ", " + "op=" +
                  to_string(node->op) + ", " + "right=" +
                  to_string(node->right);
        result += ")\n";

        depth += 2;
        result += follow(node->left) + follow(node->op) + follow(node->right);
        depth -= 2;

        return result;
    }

    std::any visitIntLit(IntLit_t node) override {
        std::string result = spaces() + to_string(node) + " IntLit(";
        result += "n=" + to_string(node->n);
        result += ")\n";

        depth += 2;
        result += follow(node->n);
        depth -= 2;

        return result;
    }

    std::any visitOperator(operator_t value) override {
        std::string result;
        switch (value) {
            case operator_t::kAdd:
                result = "Add";
                break;
            case operator_t::kSub:
                result = "Sub";
                break;
            case operator_t::kMult:
                result = "Mult";
                break;
            case operator_t::kDiv:
                result = "Div";
                break;
        }
        return result;
    }

};

std::string to_string(expr_t node) {
    ToStringVisitor string_visitor;
    return std::any_cast<std::string>(string_visitor.visit(node));
}

std::string to_string(operator_t node) {
    ToStringVisitor string_visitor;
    return std::any_cast<std::string>(string_visitor.visit(node));
}


}
